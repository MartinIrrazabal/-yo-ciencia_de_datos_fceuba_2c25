# Clase 4: Introducci√≥n a Tidyverse y Funciones Principales

**Curso**: Fundamentos del An√°lisis Program√°tico de Datos  
**Fecha**: 29 de agosto de 2025  
**Modalidad**: Virtual asincr√≥nica

## üìã Objetivos de la clase

- Comprender la historia y filosof√≠a del ecosistema tidyverse
- Configurar un entorno de trabajo organizado con gesti√≥n de carpetas
- Dominar la lectura de diferentes formatos de archivos
- Implementar las 6 operaciones fundamentales de manipulaci√≥n de datos
- Comparar tidyverse con Base R y entender cu√°ndo usar cada uno

---

## üåü ¬øQu√© es Tidyverse?

### Historia y creaci√≥n

**Tidyverse** fue creado por **Hadley Wickham** y su equipo en RStudio (ahora Posit) a partir de 2014. Hadley, estad√≠stico neozeland√©s y Chief Scientist de Posit, identific√≥ que R ten√≠a potencial enorme pero sufr√≠a de inconsistencias que dificultaban su aprendizaje y uso.

### La visi√≥n detr√°s de tidyverse

**Problema identificado**: R Base ten√≠a funciones poderosas pero:
- Sintaxis inconsistente entre funciones
- M√∫ltiples formas de hacer lo mismo
- Nombres de funciones poco intuitivos
- Estructuras de datos complejas para principiantes

**Soluci√≥n propuesta**: Un ecosistema integrado con:
- **Filosof√≠a consistente** basada en datos tidy
- **Sintaxis uniforme** entre todos los paquetes
- **Pipe operator** para c√≥digo legible
- **Documentaci√≥n excelente** y abundantes ejemplos

### Los principios de dise√±o

1. **Consistency**: todas las funciones siguen el mismo patr√≥n
2. **Composability**: las funciones se combinan f√°cilmente 
3. **Readability**: el c√≥digo debe ser legible como prosa
4. **Performance**: optimizado para casos de uso comunes

---

## ü§ù Base R vs Tidyverse: Comparaci√≥n pr√°ctica

### Ejemplo 1: Filtrar y calcular promedios

```r
# BASE R
ventas_norte <- datos_ventas[datos_ventas$region == "Norte", ]
promedio_norte <- mean(ventas_norte$ventas)

# TIDYVERSE  
promedio_norte <- datos_ventas %>%
  filter(region == "Norte") %>%
  summarise(promedio = mean(ventas)) %>%
  pull(promedio)
```

### Ejemplo 2: Crear nueva variable y agrupar

```r
# BASE R
datos_ventas$comision <- datos_ventas$ventas * 0.02
resultado <- aggregate(datos_ventas$comision, 
                      by = list(region = datos_ventas$region), 
                      FUN = sum)
names(resultado)[2] <- "total_comision"

# TIDYVERSE
resultado <- datos_ventas %>%
  mutate(comision = ventas * 0.02) %>%
  group_by(region) %>%
  summarise(total_comision = sum(comision))
```

### Ejemplo 3: Operaci√≥n compleja

```r
# BASE R (dif√≠cil de seguir)
datos_filtrados <- datos_ventas[datos_ventas$ventas > 40000, ]
datos_con_comision <- transform(datos_filtrados, 
                               comision = ventas * 0.02)
resultado_agregado <- aggregate(cbind(ventas, comision) ~ region, 
                               data = datos_con_comision, 
                               FUN = sum)
resultado_final <- resultado_agregado[order(-resultado_agregado$ventas), ]

# TIDYVERSE (f√°cil de leer)
resultado_final <- datos_ventas %>%
  filter(ventas > 40000) %>%
  mutate(comision = ventas * 0.02) %>%
  group_by(region) %>%
  summarise(ventas = sum(ventas), comision = sum(comision)) %>%
  arrange(desc(ventas))
```

### ¬øCu√°ndo usar cada uno?

**Usar Tidyverse cuando:**
- Manipulaci√≥n est√°ndar de datos
- C√≥digo que otros van a leer
- An√°lisis exploratorio
- Aprendiendo R
- Trabajo en equipo

**Usar Base R cuando:**
- Performance cr√≠tico en loops
- Paquetes que no son compatible con tidyverse
- Operaciones matem√°ticas puras
- Desarrollo de paquetes (aunque cada vez menos)

---

## üìä Tibbles vs Data Frames

### ¬øQu√© es un tibble?

Un **tibble** es la versi√≥n moderna del data.frame tradicional de R, dise√±ado para ser m√°s user-friendly.

```r
# Crear un data.frame tradicional
df_tradicional <- data.frame(
  nombre = c("Ana", "Carlos", "Diana"),
  edad = c(25, 30, 28),
  ventas = c(5000, 7500, 6200)
)

# Crear un tibble
tb_moderno <- tibble(
  nombre = c("Ana", "Carlos", "Diana"), 
  edad = c(25, 30, 28),
  ventas = c(5000, 7500, 6200)
)

# Tambi√©n pod√©s convertir
tb_convertido <- as_tibble(df_tradicional)
```

### Diferencias clave

| Aspecto | Data.frame | Tibble |
|---------|------------|--------|
| **Impresi√≥n** | Muestra todo | Solo primeras 10 filas |
| **Tipos de columna** | No siempre visible | Siempre visible |
| **Subsetting** | `df$col` o `df[["col"]]` | Mismo + warnings √∫tiles |
| **Nombres de columna** | Acepta nombres problem√°ticos | M√°s estricto |
| **Conversi√≥n de tipos** | Autom√°tica (a veces problem√°tica) | M√°s conservadora |

### Ejemplo pr√°ctico de las diferencias

```r
# Tibble muestra informaci√≥n √∫til
print(tb_moderno)
# A tibble: 3 √ó 3
#   nombre   edad ventas
#   <chr>   <dbl>  <dbl>
# 1 Ana        25   5000
# 2 Carlos     30   7500  
# 3 Diana      28   6200

# Data.frame tradicional es menos informativo
print(df_tradicional)
#    nombre edad ventas
# 1     Ana   25   5000
# 2  Carlos   30   7500
# 3   Diana   28   6200
```

---

## üîß El operador pipe (%>%): Filosof√≠a y pr√°ctica

### La revoluci√≥n del pipe

Antes de tidyverse, el c√≥digo de R se le√≠a "de adentro hacia afuera":

```r
# C√≥digo dif√≠cil de leer (anidado)
resultado <- arrange(
  summarise(
    group_by(
      filter(datos, ventas > 1000), 
      region
    ), 
    total = sum(ventas)
  ), 
  desc(total)
)

# C√≥digo con variables intermedias (verboso)
datos_filtrados <- filter(datos, ventas > 1000)
datos_agrupados <- group_by(datos_filtrados, region)  
datos_resumidos <- summarise(datos_agrupados, total = sum(ventas))
resultado <- arrange(datos_resumidos, desc(total))
```

### Con pipe: c√≥digo que se lee como prosa

```r
# C√≥digo legible de izquierda a derecha, de arriba a abajo
resultado <- datos %>%
  filter(ventas > 1000) %>%      # "toma los datos Y DESPU√âS filtra ventas > 1000"
  group_by(region) %>%           # "Y DESPU√âS agrupa por regi√≥n" 
  summarise(total = sum(ventas)) %>%  # "Y DESPU√âS suma las ventas"
  arrange(desc(total))           # "Y DESPU√âS ordena descendente"
```

### Beneficios del pipe

1. **Legibilidad**: se lee secuencialmente
2. **Debugging**: f√°cil comentar l√≠neas para probar
3. **Modificabilidad**: agregar pasos es simple
4. **Menos variables intermedias**: c√≥digo m√°s limpio

---

## üìÅ Gesti√≥n de proyectos y working directory

### Buenas pr√°cticas de organizaci√≥n

Un proyecto bien organizado facilita la reproducibilidad y colaboraci√≥n:

```
mi_proyecto/
‚îú‚îÄ‚îÄ instub/           # Datos de entrada (input)
‚îú‚îÄ‚îÄ outstub/          # Datos procesados y resultados
‚îú‚îÄ‚îÄ scripts/          # C√≥digos R
‚îî‚îÄ‚îÄ plots/            # Gr√°ficos generados
```

### Configuraci√≥n manual del working directory

```r
# Verificar directorio actual
getwd()

# Definir directorio de trabajo manualmente
setwd(r'(C:\Users\usuario\Documents\mi_proyecto)')

# Verificar que el cambio fue exitoso
getwd()
```

### Definici√≥n de carpetas y archivos

```r
# Definir carpetas de trabajo
instub <- 'instub'     # Carpeta de datos de entrada
outstub <- 'outstub'   # Carpeta de salida/resultados

# Definir nombre del archivo
archivo <- 'ventas.csv'

# Construir ruta completa
ruta_completa <- file.path(instub, archivo)

# Cargar archivo
datos <- read_csv(ruta_completa)
```

---

## üìÇ Carga de archivos: Configuraci√≥n pr√°ctica

### Configuraci√≥n inicial del entorno

```r
# Cargar librer√≠as necesarias
library(tidyverse)
library(readxl)      # Para archivos Excel
library(haven)       # Para SPSS, SAS, Stata

# Definir directorio de trabajo
setwd(r'(C:\Users\usuario\Documents\mi_proyecto)')

# Definir carpetas de trabajo
instub <- 'instub'     # Carpeta de datos de entrada
outstub <- 'outstub'   # Carpeta de resultados

# Crear carpetas si no existen
if (!dir.exists(instub)) {
  dir.create(instub, recursive = TRUE)
}

if (!dir.exists(outstub)) {
  dir.create(outstub, recursive = TRUE)
}

```

### Ejemplos de carga por formato

```r
# Definir nombre del archivo
archivo_csv <- 'ventas.csv'
archivo_excel <- 'ventas.xlsx'
archivo_txt <- 'ventas.txt'
archivo_spss <- 'encuesta.sav'

# CSV
datos_csv <- read_csv(file.path(instub, archivo_csv))

# Excel (m√∫ltiples hojas)
datos_excel_hoja1 <- read_excel(file.path(instub, archivo_excel), sheet = 1)
datos_excel_hoja2 <- read_excel(file.path(instub, archivo_excel), sheet = "Resumen")

# Archivos de texto delimitado
datos_txt <- read_delim(file.path(instub, archivo_txt), delim = ";")

# SPSS
datos_spss <- read_spss(file.path(instub, archivo_spss))
```

### Verificaci√≥n despu√©s de la carga

```r
# Verificar carga exitosa paso a paso
archivo <- 'ventas.csv'

# Cargar datos
datos_ventas <- read_csv(file.path(instub, archivo))

```

---

## üöÄ Introducci√≥n al ecosistema Tidyverse

### Los paquetes core

```r
# Al cargar tidyverse se cargan autom√°ticamente:
library(tidyverse)

# ‚úÖ readr    - Importaci√≥n de datos rectangulares
# ‚úÖ dplyr    - Manipulaci√≥n de datos
# ‚úÖ ggplot2  - Visualizaci√≥n (veremos m√°s adelante)
# ‚úÖ tibble   - Estructura de datos mejorada  
# ‚úÖ tidyr    - Reorganizaci√≥n de datos
# ‚úÖ stringr  - Manipulaci√≥n de strings
# ‚úÖ forcats  - Manejo de factores
# ‚úÖ purrr    - Programaci√≥n funcional
```

### ¬øPor qu√© tidyverse es superior?

**1. Consistencia de API**
Todas las funciones siguen el mismo patr√≥n:
- Primer argumento siempre es el dataset
- Return siempre un tibble (cuando corresponde)
- Nombres descriptivos y consistentes

**2. Composabilidad**
Las funciones est√°n dise√±adas para combinarse:

```r
# Cada funci√≥n hace UNA cosa bien
datos %>%
  filter() %>%    # Solo filtra
  mutate() %>%    # Solo crea variables
  group_by() %>%  # Solo agrupa  
  summarise()     # Solo resume
```

**3. Filosof√≠a tidy**
Todo est√° dise√±ado para trabajar con datos en formato tidy, lo que simplifica el 90% de las tareas anal√≠ticas.

---

## ‚ö° Consideraciones de performance

### Cu√°ndo usar tidyverse vs Base R

**Tidyverse es √≥ptimo para:**
- Datasets medianos (< 10M filas)
- An√°lisis exploratorio
- C√≥digo que otros van a leer
- Prototipado r√°pido

```r
# Tidyverse - r√°pido y legible
datos %>%
  filter(ventas > 1000) %>%
  group_by(region) %>%
  summarise(total = sum(ventas))
```

**Base R puede ser mejor para:**
- Datasets muy grandes (>50M filas)
- Loops intensivos
- Operaciones matem√°ticas puras
- Cuando la memoria es limitada

```r
# Base R - m√°s eficiente en memoria para loops grandes
for (i in 1:1000000) {
  # operaciones matem√°ticas intensivas
}
```

### H√≠brido: lo mejor de ambos mundos

```r
# Usar tidyverse para manipulaci√≥n + Base R para c√°lculos pesados
datos_prep <- datos %>%
  filter(fecha >= "2024-01-01") %>%
  select(vendedor, ventas, region)

# Convertir a matrix para c√°lculos r√°pidos si es necesario
matriz_ventas <- as.matrix(datos_prep[, "ventas"])
resultado_matematico <- colSums(matriz_ventas)
```

---

## üìä Las 6 operaciones fundamentales implementadas

### Datos de ejemplo para trabajar

```r
# Crear dataset de ejemplo m√°s rico
set.seed(123)
datos_ventas <- tibble(
  vendedor = rep(c("Garc√≠a", "L√≥pez", "Mart√≠n", "Silva"), each = 4),
  region = rep(c("Norte", "Sur", "Centro", "Este"), 4),
  categoria = sample(c("Electr√≥nicos", "Ropa", "Hogar"), 16, replace = TRUE),
  ventas = round(runif(16, 3000, 8000), 0),
  fecha = seq(from = as.Date("2024-01-01"), 
              to = as.Date("2024-04-15"), 
              length.out = 16),
  meta_alcanzada = sample(c(TRUE, FALSE), 16, replace = TRUE, prob = c(0.7, 0.3))
)

glimpse(datos_ventas)
```

### 1. **select()** - Seleccionar columnas

```r
# B√°sico: seleccionar por nombre
datos_ventas %>%
  select(vendedor, ventas)

# Seleccionar rango
datos_ventas %>%
  select(vendedor:categoria)

# Excluir columnas
datos_ventas %>%
  select(-fecha, -meta_alcanzada)

# Funciones helper
datos_ventas %>%
  select(starts_with("v"))        # Empieza con "v"
  
datos_ventas %>%
  select(ends_with("s"))          # Termina con "s"
  
datos_ventas %>%
  select(contains("vent"))        # Contiene "vent"

datos_ventas %>%
  select(where(is.numeric))       # Solo columnas num√©ricas

# Reordenar columnas
datos_ventas %>%
  select(ventas, everything())    # ventas primero, resto despu√©s
```

### 2. **filter()** - Filtrar filas

```r
# Filtros num√©ricos
datos_ventas %>%
  filter(ventas > 5000)

datos_ventas %>%
  filter(between(ventas, 4000, 6000))  # Entre valores

# Filtros de texto
datos_ventas %>%
  filter(vendedor == "Garc√≠a")

datos_ventas %>%
  filter(vendedor %in% c("Garc√≠a", "L√≥pez"))

datos_ventas %>%
  filter(str_detect(vendedor, "^G"))   # Empieza con G

# Filtros l√≥gicos
datos_ventas %>%
  filter(meta_alcanzada == TRUE)

# Combinar condiciones
datos_ventas %>%
  filter(ventas > 5000 & region %in% c("Norte", "Sur"))

datos_ventas %>%
  filter(ventas > 6000 | meta_alcanzada == TRUE)

# Filtros de fechas
datos_ventas %>%
  filter(fecha >= as.Date("2024-02-01"))

datos_ventas %>%
  filter(year(fecha) == 2024, month(fecha) %in% c(1, 2))
```

### 3. **mutate()** - Crear nuevas variables

```r
# Variables simples
datos_ventas %>%
  mutate(
    comision = ventas * 0.02,
    ventas_usd = ventas / 1000,  # Asumiendo tipo de cambio simplificado
    vendedor_codigo = str_sub(vendedor, 1, 3)
  )

# Variables con condicionales
datos_ventas %>%
  mutate(
    performance = ifelse(ventas >= 5000, "Alto", "Bajo"),
    
    categoria_detallada = case_when(
      ventas >= 7000 ~ "Excelente",
      ventas >= 5500 ~ "Muy bueno",
      ventas >= 4000 ~ "Bueno", 
      ventas >= 2500 ~ "Regular",
      TRUE ~ "Bajo"
    ),
    
    cumple_meta = ifelse(meta_alcanzada, "S√≠", "No")
  )

# Variables de fecha
datos_ventas %>%
  mutate(
    a√±o = year(fecha),
    mes = month(fecha, label = TRUE),
    dia_semana = wday(fecha, label = TRUE),
    trimestre = paste0("Q", quarter(fecha))
  )

# Variables de texto
datos_ventas %>%
  mutate(
    vendedor_upper = str_to_upper(vendedor),
    iniciales = paste0(str_sub(vendedor, 1, 1), str_sub(str_extract(vendedor, " \\w"), 2, 2)),
    descripcion = paste(vendedor, "vendi√≥", ventas, "en", region)
  )
```

### 4. **group_by()** - Agrupar datos

```r
# Agrupar por una variable
datos_ventas %>%
  group_by(region) %>%
  glimpse()  # Nota la l√≠nea "Groups: region [4]"

# Agrupar por m√∫ltiples variables
datos_agrupados <- datos_ventas %>%
  group_by(region, categoria)

# Verificar agrupaci√≥n
group_vars(datos_agrupados)
groups(datos_agrupados)

# Desagrupar
datos_agrupados %>%
  ungroup()
```

### 5. **summarise()** - Calcular estad√≠sticas

```r
# Resumen b√°sico
datos_ventas %>%
  summarise(
    total_ventas = sum(ventas),
    promedio_ventas = mean(ventas),
    mediana_ventas = median(ventas),
    num_observaciones = n()
  )

# Resumen por grupos
datos_ventas %>%
  group_by(region) %>%
  summarise(
    ventas_totales = sum(ventas),
    ventas_promedio = round(mean(ventas)),
    vendedores_unicos = n_distinct(vendedor),
    mejor_venta = max(ventas),
    peor_venta = min(ventas),
    rango_ventas = max(ventas) - min(ventas),
    .groups = 'drop'  # Desagrupar autom√°ticamente
  )

# M√∫ltiples agrupaciones
datos_ventas %>%
  group_by(region, categoria) %>%
  summarise(
    ventas_segmento = sum(ventas),
    transacciones = n(),
    .groups = 'keep'    # Mantener agrupaci√≥n por region
  ) %>%
  mutate(
    participacion = round(100 * ventas_segmento / sum(ventas_segmento), 1)
  )
```

### 6. **arrange()** - Ordenar datos

```r
# Ordenar ascendente (por defecto)
datos_ventas %>%
  arrange(ventas)

# Ordenar descendente
datos_ventas %>%
  arrange(desc(ventas))

# M√∫ltiples criterios
datos_ventas %>%
  arrange(region, desc(ventas))

# Dentro de grupos
datos_ventas %>%
  group_by(region) %>%
  arrange(desc(ventas), .by_group = TRUE)
```

---

## üîÑ Combinando las 6 operaciones

### An√°lisis completo paso a paso

```r
# Pipeline completo de an√°lisis
analisis_completo <- datos_ventas %>%
  # 1. Filtrar datos relevantes
  filter(fecha >= as.Date("2024-01-01")) %>%
  
  # 2. Seleccionar variables necesarias  
  select(vendedor, region, categoria, ventas, meta_alcanzada) %>%
  
  # 3. Crear variables derivadas
  mutate(
    comision = ventas * 0.025,
    performance = case_when(
      ventas >= 6500 ~ "Excelente",
      ventas >= 5000 ~ "Bueno",
      TRUE ~ "Regular"
    ),
    meta_texto = ifelse(meta_alcanzada, "Alcanz√≥", "No alcanz√≥")
  ) %>%
  
  # 4. Agrupar por caracter√≠sticas
  group_by(region, performance) %>%
  
  # 5. Calcular estad√≠sticas de grupo
  summarise(
    vendedores = n_distinct(vendedor),
    ventas_totales = sum(ventas),
    comision_total = sum(comision),
    proporcion_meta = round(100 * sum(meta_alcanzada) / n(), 1),
    .groups = 'drop'
  ) %>%
  
  # 6. Ordenar resultado final
  arrange(region, desc(ventas_totales))

print(analisis_completo)
```

---

## üÜö Comparaci√≥n detallada: Tidyverse vs Base R

### Ejemplo complejo: An√°lisis de ventas por trimestre

```r
# BASE R (verboso y complejo)
datos_ventas$trimestre <- paste0("Q", quarters(datos_ventas$fecha))
datos_ventas$comision <- datos_ventas$ventas * 0.02

# Filtrar y agrupar en Base R
datos_filtrados <- datos_ventas[datos_ventas$ventas > 4000, ]
resultado_base <- aggregate(
  cbind(ventas = datos_filtrados$ventas, comision = datos_filtrados$comision),
  by = list(region = datos_filtrados$region, 
            trimestre = datos_filtrados$trimestre),
  FUN = function(x) c(suma = sum(x), promedio = mean(x))
)

# TIDYVERSE (claro y conciso)
resultado_tidy <- datos_ventas %>%
  mutate(
    trimestre = paste0("Q", quarter(fecha)),
    comision = ventas * 0.02
  ) %>%
  filter(ventas > 4000) %>%
  group_by(region, trimestre) %>%
  summarise(
    ventas_suma = sum(ventas),
    ventas_promedio = mean(ventas),
    comision_suma = sum(comision),
    comision_promedio = mean(comision),
    .groups = 'drop'
  ) %>%
  arrange(trimestre, desc(ventas_suma))
```

### Velocidad de desarrollo: Tidyverse vs Base R

**Tidyverse ventajas:**
- ‚úÖ 70% menos l√≠neas de c√≥digo en promedio
- ‚úÖ Errores m√°s claros y descriptivos
- ‚úÖ Autocompletado mejor en IDEs
- ‚úÖ Menos consultas a documentaci√≥n
- ‚úÖ C√≥digo self-documenting

**Base R ventajas:**
- ‚úÖ Parte del R core (no dependencias externas)
- ‚úÖ M√°s r√°pido para operaciones espec√≠ficas
- ‚úÖ Mayor control de memoria
- ‚úÖ Estable en el tiempo (menos breaking changes)

---

## üìã Tibbles: La evoluci√≥n del data.frame

### Creaci√≥n de tibbles

```r
# Desde vectors
mi_tibble <- tibble(
  id = 1:5,
  nombre = c("Ana", "Bruno", "Carla", "Diego", "Elena"),
  activo = c(TRUE, TRUE, FALSE, TRUE, FALSE)
)

# Desde data.frame existente
df_viejo <- data.frame(x = 1:3, y = 4:6)
tb_nuevo <- as_tibble(df_viejo)

# Con tribble (por filas)
datos_tribble <- tribble(
  ~vendedor, ~region, ~ventas,
  "Garc√≠a",  "Norte", 5000,
  "L√≥pez",   "Sur",   6500,
  "Mart√≠n",  "Centro", 4800
)
```

### Ventajas espec√≠ficas de tibbles

```r
# 1. Impresi√≥n inteligente
print(datos_ventas)  # Solo muestra lo necesario

# 2. Subsetting m√°s estricto (evita errores)
# data.frame permite esto (puede causar problemas):
df_traditional <- data.frame(nombre = "Ana", edad = 25)
df_traditional$nom  # Devuelve "Ana" (partial matching)

# tibble es m√°s estricto:
tb_moderno <- tibble(nombre = "Ana", edad = 25)
tb_moderno$nom  # Devuelve NULL y warning

# 3. No convierte strings autom√°ticamente
tb_seguro <- tibble(
  texto = c("Hola", "Mundo"),
  numero = c(1, 2)
)
str(tb_seguro)  # texto se mantiene como character

# 4. Permite nombres de columna complejos
tb_flexible <- tibble(
  `nombre completo` = "Ana Garc√≠a",
  `a√±o de nacimiento` = 1990,
  `salario en $` = 50000
)
```

---

## üîç Funciones de exploraci√≥n avanzada

### Exploraci√≥n estructural

```r
# Informaci√≥n completa del dataset
glimpse(datos_ventas)           # Estructura compacta
str(datos_ventas)               # Estructura detallada
summary(datos_ventas)           # Estad√≠sticas por variable

# Dimensiones y nombres
dim(datos_ventas)               # [filas, columnas]
nrow(datos_ventas)              # N√∫mero de filas
ncol(datos_ventas)              # N√∫mero de columnas  
names(datos_ventas)             # Nombres de columnas
length(datos_ventas)            # N√∫mero de variables
```

### Exploraci√≥n de contenido

```r
# Primeras y √∫ltimas observaciones
head(datos_ventas)              # Primeras 6 filas (default)
head(datos_ventas, 10)          # Primeras 10 filas
tail(datos_ventas, 3)           # √öltimas 3 filas

# Muestra aleatoria
slice_sample(datos_ventas, n = 5)           # 5 filas aleatorias
slice_sample(datos_ventas, prop = 0.1)      # 10% aleatorio

# Valores √∫nicos
datos_ventas %>% 
  distinct(vendedor)            # Valores √∫nicos de vendedor

datos_ventas %>%
  count(region, sort = TRUE)    # Frecuencias ordenadas

# Verificar completitud
datos_ventas %>%
  summarise(across(everything(), ~ sum(is.na(.))))  # NAs por columna
```

### Exploraci√≥n estad√≠stica

```r
# Estad√≠sticas por variable num√©rica
datos_ventas %>%
  select(where(is.numeric)) %>%
  summary()

# Estad√≠sticas personalizadas
datos_ventas %>%
  summarise(
    ventas_min = min(ventas),
    ventas_q1 = quantile(ventas, 0.25),
    ventas_mediana = median(ventas),
    ventas_promedio = mean(ventas),
    ventas_q3 = quantile(ventas, 0.75),
    ventas_max = max(ventas),
    ventas_sd = sd(ventas),
    ventas_cv = sd(ventas) / mean(ventas)  # Coeficiente de variaci√≥n
  )

# Por grupos
datos_ventas %>%
  group_by(region) %>%
  summarise(across(where(is.numeric), 
                   list(promedio = mean, mediana = median, sd = sd),
                   .names = "{.col}_{.fn}"))
```

---

## üéÆ Casos de uso avanzados - Lo vamos a ver en otra clase 

### Trabajando con fechas

```r
# Extraer componentes de fecha
datos_ventas %>%
  mutate(
    a√±o = year(fecha),
    mes = month(fecha, label = TRUE, abbr = FALSE),
    dia = day(fecha),
    dia_semana = wday(fecha, label = TRUE),
    semana = week(fecha),
    trimestre = quarter(fecha),
    es_fin_de_semana = wday(fecha) %in% c(1, 7)
  )

# Operaciones con fechas
datos_ventas %>%
  mutate(
    dias_desde_primera_venta = as.numeric(fecha - min(fecha)),
    es_venta_reciente = fecha >= (max(fecha) - days(30))
  )
```

### Manejo de texto

```r
# Operaciones de string
datos_ventas %>%
  mutate(
    vendedor_limpio = str_trim(vendedor),          # Quitar espacios
    vendedor_lower = str_to_lower(vendedor),       # Min√∫sculas
    primera_letra = str_sub(vendedor, 1, 1),       # Primera letra
    longitud_nombre = str_length(vendedor),        # Largo del string
    contiene_r = str_detect(vendedor, "r")         # Detectar patr√≥n
  )
```

### Operaciones across m√∫ltiples columnas

```r
# Aplicar la misma funci√≥n a varias columnas
datos_ventas %>%
  summarise(across(where(is.character), n_distinct))  # Valores √∫nicos de texto

datos_ventas %>%
  group_by(region) %>%
  summarise(across(where(is.numeric), mean))          # Promedio de num√©ricas

# M√∫ltiples funciones a la vez
datos_ventas %>%
  group_by(region) %>%
  summarise(
    across(ventas, 
           list(suma = sum, promedio = mean, maximo = max),
           .names = "ventas_{.fn}")
  )
```

---

### Guardado de resultados

```r
# Guardar dataset procesado
resultado_final <- datos_ventas %>%
  group_by(region) %>%
  summarise(total = sum(ventas))

# Definir archivo de salida
archivo_salida <- "ventas_por_region_2024.csv"
ruta_salida <- file.path(outstub, archivo_salida)

# Guardar
write_csv(resultado_final, ruta_salida)
```

---

## ‚ö†Ô∏è Errores comunes y c√≥mo evitarlos

### 1. Olvidar el pipe
```r
# ‚ùå Error com√∫n
datos_ventas
filter(ventas > 5000)  # No funciona, filter no sabe qu√© datos usar

# ‚úÖ Correcto
datos_ventas %>%
  filter(ventas > 5000)
```

### 2. No desagrupar
```r
# ‚ùå Problem√°tico
datos_agrupados <- datos_ventas %>%
  group_by(region) %>%
  summarise(total = sum(ventas))
# datos_agrupados sigue agrupado!

# ‚úÖ Mejor pr√°ctica
datos_resumidos <- datos_ventas %>%
  group_by(region) %>%
  summarise(total = sum(ventas), .groups = 'drop')
```

### 3. Sobreescribir datos originales
```r
# ‚ùå Peligroso
datos_ventas <- datos_ventas %>%
  filter(ventas > 1000)  # Se perdieron las ventas <= 1000

# ‚úÖ Recomendado  
datos_ventas_filtrados <- datos_ventas %>%
  filter(ventas > 1000)  # Original intacto
```

---

## üèóÔ∏è Mejores pr√°cticas de c√≥digo

### Estilo de c√≥digo legible

```r
# ‚úÖ C√≥digo bien estructurado
resultado_final <- datos_ventas %>%
  # Paso 1: Filtrar per√≠odo de inter√©s
  filter(fecha >= as.Date("2024-01-01")) %>%
  
  # Paso 2: Crear variables necesarias
  mutate(
    trimestre = paste0("Q", quarter(fecha)),
    comision = ventas * 0.02
  ) %>%
  
  # Paso 3: Agrupar y resumir
  group_by(region, trimestre) %>%
  summarise(
    ventas_totales = sum(ventas),
    comision_total = sum(comision),
    num_ventas = n(),
    .groups = 'drop'
  ) %>%
  
  # Paso 4: Ordenar resultado
  arrange(trimestre, desc(ventas_totales))
```

### Nomenclatura consistente

```r
# ‚úÖ Nombres descriptivos y consistentes
datos_ventas_q1 <- datos_ventas %>%
  filter(quarter(fecha) == 1)

resumen_por_vendedor <- datos_ventas %>%
  group_by(vendedor) %>%
  summarise(total_ventas = sum(ventas))

top_3_regiones <- datos_ventas %>%
  group_by(region) %>%
  summarise(ventas = sum(ventas)) %>%
  arrange(desc(ventas)) %>%
  slice_head(n = 3)
```

---

## üíª Configuraci√≥n espec√≠fica por formato

### CSV y delimitados

```r
# Configuraci√≥n espec√≠fica para archivos CSV argentinos
archivo <- 'ventas_argentina.csv'

datos_csv_arg <- read_csv(
  file.path(instub, archivo),
  locale = locale(
    encoding = "UTF-8",           # Para caracteres especiales
    decimal_mark = ",",           # Coma decimal (Argentina)
    grouping_mark = "."           # Punto de miles
  ),
  na = c("", "NA", "NULL", "-", "n/a"),  # Valores que representan NA
  trim_ws = TRUE,                        # Quitar espacios extra
  show_col_types = FALSE                 # No mostrar tipos en consola
)

# Para archivos con problemas de encoding
archivo_latin <- 'datos_legacy.csv'
datos_latin <- read_csv(
  file.path(instub, archivo_latin),
  locale = locale(encoding = "latin1"),
  show_col_types = FALSE
)
```

### Excel avanzado

```r
# Explorar archivo Excel antes de cargar
archivo_excel <- 'ventas.xlsx'
ruta_excel <- file.path(instub, archivo_excel)

# Listar hojas disponibles
hojas <- excel_sheets(ruta_excel)
cat("Hojas disponibles:", paste(hojas, collapse = ", "), "\n")

# Informaci√≥n de cada hoja
for (hoja in hojas) {
  cat("\n=== HOJA:", hoja, "===\n")
  datos_estructura <- read_excel(ruta_excel, sheet = hoja, n_max = 0)  # Solo estructura
  cat("Columnas:", paste(names(datos_estructura), collapse = ", "), "\n")
}

# Cargar hoja espec√≠fica con configuraci√≥n
hoja_objetivo <- "Datos_2024"
datos_excel <- read_excel(
  ruta_excel,
  sheet = hoja_objetivo,
  skip = 2,                     # Saltar primeras 2 filas
  na = c("", "NA", "N/A", "-"),
  trim_ws = TRUE,
  guess_max = 1000             # Analizar m√°s filas para determinar tipos
)
```

---

## üìà Ejemplo integrado completo

```r
# === AN√ÅLISIS COMPLETO CON TIDYVERSE ===

# 1. CONFIGURACI√ìN Y CARGA
library(tidyverse)

# Simular carga desde archivo (en la pr√°ctica ser√≠a read_csv)
datos_completos <- tibble(
  id_venta = 1:50,
  fecha_venta = seq(as.Date("2024-01-01"), as.Date("2024-03-15"), length.out = 50),
  vendedor = sample(c("Garc√≠a", "L√≥pez", "Mart√≠n", "Silva", "Rodr√≠guez"), 50, replace = TRUE),
  sucursal = sample(c("Centro", "Norte", "Sur", "Este"), 50, replace = TRUE),
  categoria = sample(c("Electr√≥nicos", "Ropa", "Hogar", "Deportes"), 50, replace = TRUE),
  cantidad = sample(1:10, 50, replace = TRUE),
  precio_unitario = round(runif(50, 50, 500), 2),
  descuento_pct = sample(c(0, 5, 10, 15), 50, replace = TRUE, prob = c(0.4, 0.3, 0.2, 0.1))
) %>%
  mutate(
    subtotal = cantidad * precio_unitario,
    descuento_monto = subtotal * (descuento_pct / 100),
    total_venta = subtotal - descuento_monto
  )

# 2. EXPLORACI√ìN INICIAL
cat("=== EXPLORACI√ìN DEL DATASET ===\n")
glimpse(datos_completos)

# Verificar calidad de datos
datos_completos %>%
  summarise(
    filas_totales = n(),
    across(everything(), ~ sum(is.na(.))),
    .names = "na_{.col}"
  )

# 3. AN√ÅLISIS MULTIDIMENSIONAL
analisis_ejecutivo <- datos_completos %>%
  # Crear variables de an√°lisis
  mutate(
    mes = month(fecha_venta, label = TRUE),
    trimestre = paste0("Q", quarter(fecha_venta)),
    ticket_promedio = total_venta / cantidad,
    categoria_descuento = case_when(
      descuento_pct == 0 ~ "Sin descuento",
      descuento_pct <= 10 ~ "Descuento moderado", 
      TRUE ~ "Descuento alto"
    )
  ) %>%
  
  # An√°lisis por vendedor y sucursal
  group_by(vendedor, sucursal) %>%
  summarise(
    ventas_brutas = sum(subtotal),
    descuentos_otorgados = sum(descuento_monto),
    ventas_netas = sum(total_venta),
    transacciones = n(),
    ticket_promedio = round(mean(total_venta)),
    margen_descuento = round(100 * sum(descuento_monto) / sum(subtotal), 1),
    .groups = 'drop'
  ) %>%
  
  # Ranking y categorizaci√≥n
  mutate(
    eficiencia = round(ventas_netas / transacciones),
    ranking_ventas = dense_rank(desc(ventas_netas)),
    performance = case_when(
      ventas_netas >= quantile(ventas_netas, 0.8) ~ "Top 20%",
      ventas_netas >= quantile(ventas_netas, 0.6) ~ "Bueno", 
      ventas_netas >= quantile(ventas_netas, 0.4) ~ "Promedio",
      TRUE ~ "Bajo rendimiento"
    )
  ) %>%
  
  arrange(ranking_ventas)

print(analisis_ejecutivo)
```
